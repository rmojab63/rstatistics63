---
title: "مثال ۳-۴: محاسبهٔ رتبه (یک راهکار برای مقایسهٔ کارایی دو تابع یا الگوریتم رقیب)"
author: "رامین مجاب"
output: md_document
---

**(صفحهٔ ۱۰۲ کتاب)**

در **R**، رتبهٔ یک ماتریس را می‌توان به طرق مختلف محاسبه کرد. بدون استفاده از بسته‌های خارجی، تابع `qr()` رتبهٔ ماتریس را در کنار برخی دیگر اطلاعات محاسبه می‌کند. بااین‌حال، از بستهٔ نرم‌افزاری `Matrix` که پیش‌تر معرفی شد نیز می‌توان استفاده کرد. در مثال زیر، هر دو روش استفاده می‌شود. البته، هدف صرفاً استفاده از یک تابع نیست، بلکه در نظر داریم کارایی این دو روش را نیز از منظر زمان موردنیاز برای انجام عملیات‌ها با یکدیگر مقایسه کنیم. کد زیر را ملاحظه کنید:
```{r}	
t1 <- t2 <- 0
for (i in 1:10000) {
  n <- sample(2:20, 1) # Random size
  A <- matrix(data = rnorm(n^2), nrow = n)
  start_time <- Sys.time()
  rank <- qr(A)$rank
  end_time <- Sys.time()
  t1 <- t1 + end_time - start_time

  start_time <- Sys.time()
  rank <- Matrix::rankMatrix(A)
  end_time <- Sys.time()
  t2 <- t2 + end_time - start_time
}

cat("Time taken, using qr():", t1, ", using rankMatrix():", t2)

```
خروجی تابع `Sys.time()`، زمان سیستم کامپیوتر است.  زمان در دو نقطه را می‌توان از یکدیگر کسر  و تفاوت را محاسبه کرد (آنچه در `end_time - start_time` انجام می‌شود). در مقایسهٔ زمان انجام عملیات‌ها به چند نکته توجه کنید: 

- یک عملیات را چندبار تکرار می‌کنیم. در اینجا، `10000` بار رتبهٔ یک ماتریس توسط دو روش موردنظر مقایسه می‌شود. 
- ماتریس را به‌صورت تصادفی در حلقهٔ `for` محاسبه می‌کنیم تا نتایج به  ارزش‌های ماتریس حساس نباشند.
- هیچ عملیاتی به‌جز توابع موردنظر نباید بین دو خط دستوری که زمان آغاز و پایان را محاسبه می‌کنند، وجود داشته باشد. 
- از یک حلقهٔ `for` واحد باید استفاده شود تا محاسبه بر ماتریس‌های یکسانی انجام گیرد و همچنین تأثیر نوسانات درونی سیستم کامپیوتری بر نتایج حداقل شود. 
- هدف در اینجا نه قضاوت دربارهٔ هرکدام از توابع، بلکه صرفاً طرح موضوع است. هرکدام از این توابع، گزینه‌های مختلف دیگری دارد که درنظرگرفتن آن‌ها برای قضاوت نهایی مهم است.


