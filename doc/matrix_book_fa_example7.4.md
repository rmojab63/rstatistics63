---
title: "مثال ۷-۴: بررسی مثبت معین‌بودن ماتریس (معرفی بلوک `try-catch`)"
author: "رامین مجاب"
output: md_document
---
##  مثال ۷-۴: بررسی مثبت معین‌بودن ماتریس (معرفی بلوک `try-catch`)
<p style='font-size: 0.8em;'><b>نویسنده:</b> <span>رامین مجاب</span></p>

**(صفحهٔ ۲۵۳ کتاب)**

برای محاسبهٔ تجزیهٔ چولسکی یک ماتریس در **R**، از تابع `chol()` استفاده می‌کنیم. بااین‌حال، ماتریس باید مثبت معین باشد، زیرا در غیر این‌صورت، فرایند اجرای کد با خطا متوقف می‌شود. همان‌طور که در بخش دوم کتاب بحث می‌شود، ماتریس‌های واریانس (عموماً) از لحاظ نظریه، مثبت معین هستند. در موارد چندی، نیاز به تجزیه‌کردن آن‌ها توسط تجزیهٔ چولسکی وجود دارد. در اینجا نیز همانند [مثال ۵-۳](matrix_book_fa_example5.3)،  خطای گردشدن اعداد مطرح می‌شود و ممکن است در یک مرحله از کد، ماتریس حتی قرینه نباشد (بحث این مثال را مطالعه کنید).  

فارغ از نکتهٔ فوق، ممکن است از لحاظ نظری مطمئن نباشیم که ماتریس مثبت معین است و بخواهیم از تابع `chol()` استفاده کنیم. در [مثال ۷-۳](matrix_book_fa_example7.3)، از تابع `eigen()` برای بررسی مثبت معین‌بودن استفاده کردیم. اینکه یک‌بار از این تابع استفاده کنیم و سپس از تابع `chol()` استفاده کنیم، قطعاً کارا نیست. اگرچه باید همانند [مثال ۳-۴](matrix_book_fa_example3.4)، زمان انجام فرایندهای مختلف را در سیستم کامپیوتری خود با دیگر فرایندها مقایسه کنیم، اما احتمالاً بهترین انتخاب استفاده از تابع `chol()` باشد. اگر تابع مثبت معین نباشد، این تابع با خطا متوقف می‌شود، که البته مشکل اصلی هم همین‌جاست: اینکه فرایند اجرای کد متوقف می‌شود؛ مثلاً، کد زیر و خطای ایجادشده در آن را ملاحظه کنید:

``` r
> A <- matrix(c(1, 2, 3, 4), nrow = 2)
> P <- chol(A)
```

```
# Error in chol.default(A): the leading minor of order 2 is not positive
```
پس، پرسش مهم آن است که اگر فرایند با خطا متوقف می‌شود، چطور به **R** بفهمانیم که این صرفاً یک بررسی اولیه است و در منطق کدهای خود، خطا  را لحاظ کرده‌ایم: «متوقف نشو و بقیهٔ خطوط را اجرا کن!» بد نبود اگر تابع `chol()`، در صورت عدم‌موفقیت، مثلاً ارزش `NULL` یا `FALSE` را برمی‌گرداند.  به دلایلی که برای بحث ما مهم نیست، این تابع را این‌گونه طراحی نکرده‌اند. بااین‌حال، نوشتن یک تابع با این ویژگی، با استفاده از بلوک `tryCatch()` ساده است. کد زیر را مطالعه کنید:


``` r
> chol.trycatch <- function(A) {
+   tryCatch(
+     {
+       chol(A)
+     },
+     error = function(e) {
+       NULL
+     }
+   )
+ }
```
منطق ساده است: خطا در ورودیِ اولِ بلوک `tryCatch` باعث می‌شود ورودی `error` که یک تابع است، اجرا شود. این بلوک  گزینه‌های دیگری نیز دارد؛ مثلاً، استفاده از ورودی `finally` در این تابع می‌تواند در بعضی موارد مفید باشد (با توجه به نحوهٔ مدیریت حافظه در **R**، شاید  به این گزینه نیاز چندانی نداشته باشید، ولی اگر مثلاً یک `connection`  به بسته‌شدن نیاز داشته باشد، باید از این گزینه استفاده کنید).

در کد زیر،‌ از این تابع استفاده می‌کنیم:

``` r
> P <- chol.trycatch(A)
> if (is.null(P)) {
+   print("continue without Cholesky decomposition!")
+ } else {
+   print("use P :)")
+ }
```

```
# [1] "continue without Cholesky decomposition!"
```

اگر هدف شناسایی ماتریس مثبت معین باشد، تابع `chol.trycatch()` یک تابع چندان مفید نیست، زیرا ممکن است ماتریس، مربع یا متقارن نباشد و به این دلایل تابع `chol()` با خطا متوقف شود. احتمالاً بهتر باشد در این مواقع `NULL` بازنگردد، بلکه کد متوقف شود، زیرا یک ایراد منطقی وجود دارد. به‌عنوان تمرین، چند راهکار برای بهبود منطق این تابع پیاده‌سازی کنید (از عضو `e` در این بخش از کد: `error = function(e)` نیز استفاده کنید).



<p style='margin-bottom:3cm;'></p><hr/>

- [مثال ۷-۳: تعیین نوع ماتریس‌ها از  منظر مثبت یا منفی معین‌بودن (یک مثال دیگر از نیاز به مدیریت خطای گِردشدن)](matrix_book_fa_example7.3.html)
- [مثال ۸-۱: مشتق‌گیری (مفهوم عبارت)](matrix_book_fa_example8.1.html)
- [<b>لیست مثال‌ها</b>](matrix_book_fa.html)
