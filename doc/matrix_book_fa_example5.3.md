---
title: "مثال ۵-۳: ادامهٔ تجزیهٔ ویژه (انباشت خطای گردشدن اعداد و مشکلات ناشی از آن‌ها)"
author: "رامین مجاب"
output: md_document
---
##  مثال ۵-۳: ادامهٔ تجزیهٔ ویژه (انباشت خطای گردشدن اعداد و مشکلات ناشی از آن‌ها)
<p style='font-size: 0.8em;'><b>نویسنده:</b> <span>رامین مجاب</span></p>

**(صفحهٔ ۱۸۶ کتاب)**

برای این مثال، فرض کنید که یک ماتریس از دید نظری (یعنی وقتی معادلات بر کاغذ نوشته می‌شود) متقارن است، اما به‌دلیل خطای گردشدن داده‌ها در کامپیوتر، تااندازه‌ای این ویژگی را از دست می‌دهد. کد زیر را ملاحظه کنید:

``` r
> A <- matrix(c(1, 2 + 1e-13, 3, 2, 4, 5, 3, 5, 6), nrow = 3)
> isSymmetric(A)
```

```
# [1] FALSE
```
این یک سناریوسازی برای توضیحات قبل است، به این‌صورت که ماتریس `A` باید متقارن باشد، اما یک خطای نسبتاً کوچک به اندازهٔ `1e-13` در نتیجهٔ محاسبات در آن ایجاد شده است. در تابع `eigen()`، یکی از ورودی‌ها با نام `symmetric`، می‌تواند ارزش `boolean` بگیرد، تا الگوریتمی کاراتر و دقیق‌تر برای ماتریس‌های متقارن استفاده شود. اکنون، باوجود این‌گونه خطاها، شما کدام‌یک از مسیرهای زیر انتخاب می‌کنید:

-  ماتریس را با دستوری نظیر 	`A <- 0.5 * (A + t(A))` متقارن  و سپس از الگوریتم متقارن استفاده می‌کنید.
- ماتریس را متقارن نمی‌کنید و در وضعیت فعلی از الگوریتم متقارن استفاده می‌کنید.
- از الگوریتم متقارن استفاده نمی‌کنید.

بررسی این موارد برای مثال فوق، به‌عنوان تمرین واگذار می‌شود.  توجه کنید که شاید نتوان پاسخ مشخصی برای برتر دانستن هرکدام از این گزینه‌ها بر دیگری یافت. همچنین، ممکن است یک گزینهٔ چهارم نیز وجود داشته باشد و آن اینکه الگوریتم‌های پیشین را که باعث می‌شوند یک ماتریس متقارن (از دید نظریه)، نامتقارن گزارش شود، بازنگری کنیم.

در رابطه با فیلتر کالمن در فصل ۱۶ (صفحهٔ ۴۴۷ کتاب)، بحث این مثال و نامتقارن‌شدنِ عددیِ ماتریس‌های ذاتاً متقارن مهم می‌شود. در آنجا، از یک الگوریتم جایگزین صحبت خواهیم کرد.


<p style='margin-bottom:3cm;'></p><hr/>

- [مثال ۵-۲: تجزیهٔ ویژه (مسئولیت اشتباهات)](matrix_book_fa_example5.2.html)
- [مثال ۵-۴: محاسبهٔ بردارهای ویژهٔ تعمیم‌یافته (تفاوت حل عددی و حل نمادی)](matrix_book_fa_example5.4.html)
- [<b>لیست مثال‌ها</b>](matrix_book_fa.html)
