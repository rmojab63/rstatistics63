---
title: "مثال ۳-۲: فضای برداری \\\\(\\mathbb{R}^2\\\\) (رسم شکل)"
author: "رامین مجاب"
output: md_document
---
##  مثال ۳-۲: فضای برداری \\(\mathbb{R}^2\\) (رسم شکل)
<p style='font-size: 0.8em;'><b>نویسنده:</b> <span>رامین مجاب</span></p>

**(صفحهٔ ۷۸ کتاب)**

شکل و نمودار می‌تواند به درک مطلب کمک کند و در این مثال سعی می‌کنیم مفاهیم را با رسم نمودار در **R** توضیح دهیم. در ابتدا تابعی می‌نویسیم تا یک بردار را در $\mathbb{R}^2$ رسم کنیم:

``` r
> plot.vector <- function(vec = c(1, 1), newPlot = TRUE) {
+   if (newPlot) {
+     plot(0,
+       type = "n", xlim = c(-2, 2),
+       ylim = c(-4, 4), asp = 1
+     )
+     grid(
+       nx = NULL, ny = NULL,
+       col = "lightgray", lty = "dotted"
+     )
+   }
+   arrows(0, 0, vec[1], vec[2],
+     length = 0.1,
+     angle = 30, lwd = 2
+   )
+ }
```
اولین ورودی، برداری است که تمایل داریم رسم شود. دومین ورودی تعیین می‌کند که آیا بردار بر نمودار فعلی رسم شود یا خیر. هر دو  ورودی  مقدار پیش‌فرض (یعنی `default`) دارند. پس، در فراخوانی تابع می‌توانیم ارزشی برای این ورودی‌ها تعیین نکنیم و اجازه دهیم تابع از مقدار پیش‌فرض استفاده کند (یعنی، تابع `plot.vector()` بدون هیچ ورودی نیز اجرا می‌شود و یک بردار از مبدأ به نقطه $(1,1)$ رسم می‌کند).

در این تابع، سه تابع `plot()`، `grid()`، و `arrows()` فراخوانی می‌شود تا صفحهٔ مختصات $x-y$  را در صورت نیاز (اگر `newPlot = TRUE` باشد) ترسیم کند و سپس بردار به‌صورت فلش اضافه شود. 

در تابع `plot()` و دیگر توابع، مقادیر پیش‌فرضی انتخاب شده است و بنابراین با فراخوانی این تابع، نمی‌توانید مثلاً رنگ متفاوتی برای خطوط انتخاب کنید یا حداقل و حداکثر محورها را تغییر دهید. بنابراین، این تابع بسیار ابتدایی است و احتمالاً کاربرد عمومی برای رسم بردار نخواهد داشت. 
به‌عنوان تمرین، تابع فوق را تغییر دهید و مقدار `xlim` و `ylim` را نیز به‌عنوان   ورودی‌های دیگر در تابع تعریف کنید.

در **R**، برای عمومی‌ترکردن یک تابع راهکار ساده‌ای وجود دارد. پس در کد زیر، تابع را کمی حرفه‌ای‌تر می‌نویسیم:

``` r
> plot.vector <- function(vec = c(1, 1), newPlot = FALSE,
+                         label = "", ...) {
+   if (newPlot) {
+     default_args <- list(
+       xlim = c(-2, 2), ylim = c(-2, 2),
+       asp = 1, col = "black"
+     )
+   } else {
+     default_args <- list(
+       length = 0.1, angle = 30, lwd = 2,
+       col = "black"
+     )
+   }
+   user_args <- list(...)
+   args <- modifyList(default_args, user_args)
+   if (newPlot) {
+     do.call("plot", c(list(0, type = "n"), args))
+     grid(
+       nx = NULL, ny = NULL, col = "lightgray",
+       lty = "dotted"
+     )
+   } else {
+     do.call("arrows", c(list(0, 0, vec[1], vec[2]), args))
+     text(
+       x = vec[1], y = vec[2], labels = label, pos = 3,
+       col = args$col
+     )
+   }
+ }
```
چند تغییر در تابع نسبت به تابع قبل لازم بود. اولین تغییر معرفی `...` به‌عنوان یک ورودی برای تابع است. این نماد اصطلاحاً `ellipsis` یا `three dots` خوانده می‌شود و می‌توان با استفاده از آن، ورودی‌های متغیری را به تابع منتقل کرد. در تابع`plot.vector()`، این ورودی‌ها به تابع `plot()` یا `arrows()` منتقل می‌شود. بنابراین، اگر تابع `plot()` دارای ورودی `xlab` است، تابع `plot.vector()` نیز این ورودی را با همان کارکرد خواهد گرفت. دومین تغییر به این موضوع برمی‌گردد که ما مقادیر پیش‌فرضی برای تابع `plot()` داشتیم. اگر کد را به‌صورت `plot(x, y, type = "l", asp = 1, xlab = NA, ylab = NA)` بنویسیم، دیگر نمی‌توانیم ورودی `xlab` را در `...` وارد کنیم (خطایی رخ می‌دهد به این مضمون که یک ورودی دوبار تعریف شده است). 

یک راهکار برای حل مشکل دوبار تعریف‌کردن ورودی‌ها در `...` آن است که مقادیر پیش‌فرض را درون لیست `default_args` می‌گذاریم و سپس، با استفاده از تابع `modifyList()`، لیست `...` را اصلاح می‌کنیم. اگر مقدار پیش‌فرضی در `...` وجود نداشته باشد، آن اضافه می‌شود و در غیر این‌صورت،  تغییر نمی‌کند. 

سومین تغییر به این موضوع برمی‌گردد که اکنون، ورودی‌های تابع `plot()` یا `arrows()` درون یک لیست قرار دارند و مستقیماً نمی‌توانیم تابع `plot()` را فراخوانی کنیم. برای فراخوانی این تابع، از تابع `do.call()` به‌نحوی که نشان داده شده است، استفاده می‌کنیم. 

در نهایت، نقش ورودی `newPlot` را تا اندازه‌ای تغییر داده‌ایم، به‌طوری‌که اگر ارزش آن `TRUE` باشد، یک صفحهٔ مختصات جدید ترسیم شود و برداری رسم نمی‌شود. در غیر این‌صورت، از  صفحهٔ فعلی برای رسم استفاده می‌شود. دلیلش آن است که نمی‌خواهیم دو لیست متفاوت `args` برای دو  تابع `arrows()` و `plot()` وجود داشته باشد. 

به‌عنوان تمرین،  توضیح دهید که چرا نباید پارامترهای تابع `plot()` را با `newPlot=FALSE`  در `...` تعریف کنیم.

اکنون به بحث اصلی، یعنی رسم بردارهای وابسته و مستقل بازمی‌گردیم. کد زیر را ملاحظه کنید:


``` r
> plot.vector(newPlot = TRUE, xlim = c(0, 3), ylim = c(0, 3))
> plot.vector(vec = c(2, 2), col = "black")
> plot.vector(vec = c(1, 1), col = "red")
> plot.vector(vec = c(1, 2), col = "blue")
> plot.vector(vec = c(0, 2.5), col = "green", lty = 2)
> plot.vector(vec = c(0.8, 0), col = "orange", lty = 2)
```

<img src="/rstatistics63/assets/images/matrix_book_fa/fig_vector_space-1.svg" style="display: block; margin: auto;" />
به‌عنوان تمرین، بگویید که در نمودار رسم‌شده، کدام‌یک از بردارها وابسته و کدام‌یک مستقل‌اند. همچنین، اهمیت `asp=1` را که به‌عنوان پیش‌فرض در رسم نمودار قرار داده شده است، بیابید و توضیح دهید.  برای تابع و با استفاده از تابع `warning()`، وقتی در `...` ارزش متفاوتی برای این پارامتر انتخاب می‌شود، یک اخطار وارد کنید.

به‌عنوان آخرین نکته، توجه کنید که   بستهٔ نرم‌افزاری `ggplot2` <span dir="ltr">(Wickham, Chang, Henry et al., 2024)</span> ابزار قدرتمندتر و منعطف‌تری برای رسم شکل‌های دوبعدی در **R** است. بااین‌حال، گرامر استفاده از این بسته تااندازه‌ای متفاوت و پیچیده است. بنابراین، با توجه به اهداف این کتاب، ‌به این معرفی قناعت می‌شود.



### References

[1] H. Wickham, W. Chang, L. Henry, et al. _ggplot2: Create Elegant Data
Visualisations Using the Grammar of Graphics_. R package version 3.5.1. 2024.
<https://ggplot2.tidyverse.org>.


<p style='margin-bottom:3cm;'></p><hr/>

- [مثال ۳-۱: بررسی استقلال و وابستگی خطی (تفاوت صفر در ریاضیات و صفر در محاسبات)](matrix_book_fa_example3.1.html)
- [مثال ۳-۳: نُرم یک بردار (معرفی برخی توابع و عملیات‌ها)](matrix_book_fa_example3.3.html)
- [<b>لیست مثال‌ها</b>](matrix_book_fa.html)
